# .github/workflows/ci.yml

name: Java CI with Maven and Services

# Controls when the workflow will run
on:
  push:
    branches: [ "master" ] # Runs on pushes to the main branch
  pull_request:
    branches: [ "master" ] # Runs on pull requests targeting the main branch

jobs:
  build-and-test:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    # Define the working directory if your pom.xml and docker-compose.yml are not at the root
    # defaults:
    #   run:
    #     working-directory: ./Journal-Spring # Uncomment and adjust if needed

    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout code
        uses: actions/checkout@v4

      # Sets up Java JDK 17
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin' # Popular distribution

      # Cache Maven packages to speed up build
      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository # The directory to cache
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }} # Cache key based on OS and pom.xml
          restore-keys: |
            ${{ runner.os }}-maven- # Fallback cache key

      # Grant execute permission for the mvnw script
      - name: Grant execute permission for mvnw
        run: chmod +x ./mvnw
        # If using working-directory, adjust the path:
        # run: chmod +x ./Journal-Spring/mvnw

      # Start services using Docker Compose V2 command (docker compose)
      # Ensure your docker-compose.yml defines the necessary services (like postgres)
      - name: Start Docker Compose services
        env:
          # Map GitHub Secrets to environment variables used by docker-compose.yml or tests
          # Ensure these names match what your docker-compose.yml or application-test.properties expects
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          # Add other secrets needed by docker-compose services if any
        run: docker compose up -d # Changed from docker-compose
        # If using working-directory, adjust the path:
        # run: docker compose -f ./Journal-Spring/docker-compose.yml up -d

      # Optional: Wait for services (e.g., database) to be ready
      # This simple sleep might work, or use a more robust health check script
      - name: Wait for services
        run: sleep 15 # Adjust time as needed

      # Run tests using the Maven wrapper
      # Pass secrets needed directly by the tests (not via docker-compose) as environment variables
      - name: Build and run tests with Maven
        env:
          # Secrets needed by application-test.properties or the tests themselves
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }} # Or your default region
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          ENCRYPTION_PASSWORD: ${{ secrets.ENCRYPTION_PASSWORD }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # Ensure DB connection details in application-test.properties point to Docker Compose service
          # e.g., spring.datasource.url=jdbc:postgresql://localhost:5432/${{ secrets.DB_NAME }}
          # (Assuming docker-compose maps port 5432 to localhost)
          SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/${{ secrets.DB_NAME }} # Adjust if needed
          # Add any other env vars your tests require
        run: ./mvnw test
        # If using working-directory, adjust the path:
        # run: ./Journal-Spring/mvnw test

      # Stop Docker Compose services regardless of test success/failure using V2 command
      - name: Stop Docker Compose services
        if: always() # Ensure cleanup runs even if tests fail
        run: docker compose down # Changed from docker-compose
        # If using working-directory, adjust the path:
        # run: docker compose -f ./Journal-Spring/docker-compose.yml down

      # Optional: Upload test results (useful for debugging failures)
      - name: Upload test reports
        if: failure() # Only upload reports if tests fail
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: target/surefire-reports/
          # If using working-directory, adjust the path:
          # path: ./Journal-Spring/target/surefire-reports/
